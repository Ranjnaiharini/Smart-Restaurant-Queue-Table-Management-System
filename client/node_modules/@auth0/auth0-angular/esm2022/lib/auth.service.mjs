import { Injectable, Inject } from '@angular/core';
import { of, from, Subject, iif, defer, ReplaySubject, throwError, } from 'rxjs';
import { concatMap, tap, map, takeUntil, catchError, switchMap, withLatestFrom, } from 'rxjs/operators';
import { Auth0ClientService } from './auth.client';
import * as i0 from "@angular/core";
import * as i1 from "./auth.config";
import * as i2 from "./abstract-navigator";
import * as i3 from "./auth.state";
import * as i4 from "@auth0/auth0-spa-js";
export class AuthService {
    constructor(auth0Client, configFactory, navigator, authState) {
        this.auth0Client = auth0Client;
        this.configFactory = configFactory;
        this.navigator = navigator;
        this.authState = authState;
        this.appStateSubject$ = new ReplaySubject(1);
        // https://stackoverflow.com/a/41177163
        this.ngUnsubscribe$ = new Subject();
        /**
         * Emits boolean values indicating the loading state of the SDK.
         */
        this.isLoading$ = this.authState.isLoading$;
        /**
         * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.
         * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.
         */
        this.isAuthenticated$ = this.authState.isAuthenticated$;
        /**
         * Emits details about the authenticated user, or null if not authenticated.
         */
        this.user$ = this.authState.user$;
        /**
         * Emits ID token claims when authenticated, or null if not authenticated.
         */
        this.idTokenClaims$ = this.authState.idTokenClaims$;
        /**
         * Emits errors that occur during login, or when checking for an active session on startup.
         */
        this.error$ = this.authState.error$;
        /**
         * Emits the value (if any) that was passed to the `loginWithRedirect` method call
         * but only **after** `handleRedirectCallback` is first called
         */
        this.appState$ = this.appStateSubject$.asObservable();
        const checkSessionOrCallback$ = (isCallback) => iif(() => isCallback, this.handleRedirectCallback(), defer(() => this.auth0Client.checkSession()));
        this.shouldHandleCallback()
            .pipe(switchMap((isCallback) => checkSessionOrCallback$(isCallback).pipe(catchError((error) => {
            const config = this.configFactory.get();
            this.navigator.navigateByUrl(config.errorPath || '/');
            this.authState.setError(error);
            return of(undefined);
        }))), tap(() => {
            this.authState.setIsLoading(false);
        }), takeUntil(this.ngUnsubscribe$))
            .subscribe();
    }
    /**
     * Called when the service is destroyed
     */
    ngOnDestroy() {
        // https://stackoverflow.com/a/41177163
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
    }
    /**
     * ```js
     * loginWithRedirect(options);
     * ```
     *
     * Performs a redirect to `/authorize` using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated.
     *
     * @param options The login options
     */
    loginWithRedirect(options) {
        return from(this.auth0Client.loginWithRedirect(options));
    }
    /**
     * ```js
     * await loginWithPopup(options);
     * ```
     *
     * Opens a popup with the `/authorize` URL using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated. If the response is successful,
     * results will be valid according to their expiration times.
     *
     * IMPORTANT: This method has to be called from an event handler
     * that was started by the user like a button click, for example,
     * otherwise the popup will be blocked in most browsers.
     *
     * @param options The login options
     * @param config Configuration for the popup window
     */
    loginWithPopup(options, config) {
        return from(this.auth0Client.loginWithPopup(options, config).then(() => {
            this.authState.refresh();
        }));
    }
    /**
     * ```js
     * logout();
     * ```
     *
     * Clears the application session and performs a redirect to `/v2/logout`, using
     * the parameters provided as arguments, to clear the Auth0 session.
     * If the `federated` option is specified it also clears the Identity Provider session.
     * If the `openUrl` option is set to false, it only clears the application session.
     * It is invalid to set both the `federated` to true and `openUrl` to `false`,
     * and an error will be thrown if you do.
     * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).
     *
     * @param options The logout options
     */
    logout(options) {
        return from(this.auth0Client.logout(options).then(() => {
            if (options?.openUrl === false || options?.openUrl) {
                this.authState.refresh();
            }
        }));
    }
    /**
     * ```js
     * getAccessTokenSilently(options).subscribe(token => ...)
     * ```
     *
     * If there's a valid token stored, return it. Otherwise, opens an
     * iframe with the `/authorize` URL using the parameters provided
     * as arguments. Random and secure `state` and `nonce` parameters
     * will be auto-generated. If the response is successful, results
     * will be valid according to their expiration times.
     *
     * If refresh tokens are used, the token endpoint is called directly with the
     * 'refresh_token' grant. If no refresh token is available to make this call,
     * the SDK falls back to using an iframe to the '/authorize' URL.
     *
     * This method may use a web worker to perform the token call if the in-memory
     * cache is used.
     *
     * If an `audience` value is given to this function, the SDK always falls
     * back to using an iframe to make the token exchange.
     *
     * Note that in all cases, falling back to an iframe requires access to
     * the `auth0` cookie, and thus will not work in browsers that block third-party
     * cookies by default (Safari, Brave, etc).
     *
     * @param options The options for configuring the token fetch.
     */
    getAccessTokenSilently(options = {}) {
        return of(this.auth0Client).pipe(concatMap((client) => options.detailedResponse === true
            ? client.getTokenSilently({ ...options, detailedResponse: true })
            : client.getTokenSilently(options)), tap((token) => {
            if (token) {
                this.authState.setAccessToken(typeof token === 'string' ? token : token.access_token);
            }
        }), catchError((error) => {
            this.authState.setError(error);
            this.authState.refresh();
            return throwError(error);
        }));
    }
    /**
     * ```js
     * getTokenWithPopup(options).subscribe(token => ...)
     * ```
     *
     * Get an access token interactively.
     *
     * Opens a popup with the `/authorize` URL using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated. If the response is successful,
     * results will be valid according to their expiration times.
     */
    getAccessTokenWithPopup(options) {
        return of(this.auth0Client).pipe(concatMap((client) => client.getTokenWithPopup(options)), tap((token) => {
            if (token) {
                this.authState.setAccessToken(token);
            }
        }), catchError((error) => {
            this.authState.setError(error);
            this.authState.refresh();
            return throwError(error);
        }));
    }
    /**
     * ```js
     * handleRedirectCallback(url).subscribe(result => ...)
     * ```
     *
     * After the browser redirects back to the callback page,
     * call `handleRedirectCallback` to handle success and error
     * responses from Auth0. If the response is successful, results
     * will be valid according to their expiration times.
     *
     * Calling this method also refreshes the authentication and user states.
     *
     * @param url The URL to that should be used to retrieve the `state` and `code` values. Defaults to `window.location.href` if not given.
     */
    handleRedirectCallback(url) {
        return defer(() => this.auth0Client.handleRedirectCallback(url)).pipe(withLatestFrom(this.authState.isLoading$), tap(([result, isLoading]) => {
            if (!isLoading) {
                this.authState.refresh();
            }
            const appState = result?.appState;
            const target = appState?.target ?? '/';
            if (appState) {
                this.appStateSubject$.next(appState);
            }
            this.navigator.navigateByUrl(target);
        }), map(([result]) => result));
    }
    /**
     * ```js
     * getDpopNonce(id).subscribe(nonce => ...)
     * ```
     *
     * Gets the DPoP nonce for the specified domain or the default domain.
     * The nonce is used in DPoP proof generation for token binding.
     *
     * @param id Optional identifier for the domain. If not provided, uses the default domain.
     * @returns An Observable that emits the DPoP nonce string or undefined if not available.
     */
    getDpopNonce(id) {
        return from(this.auth0Client.getDpopNonce(id));
    }
    /**
     * ```js
     * setDpopNonce(nonce, id).subscribe(() => ...)
     * ```
     *
     * Sets the DPoP nonce for the specified domain or the default domain.
     * This is typically used after receiving a new nonce from the authorization server.
     *
     * @param nonce The DPoP nonce value to set.
     * @param id Optional identifier for the domain. If not provided, uses the default domain.
     * @returns An Observable that completes when the nonce is set.
     */
    setDpopNonce(nonce, id) {
        return from(this.auth0Client.setDpopNonce(nonce, id));
    }
    /**
     * ```js
     * generateDpopProof(params).subscribe(proof => ...)
     * ```
     *
     * Generates a DPoP (Demonstrating Proof-of-Possession) proof JWT.
     * This proof is used to bind access tokens to a specific client, providing
     * an additional layer of security for token usage.
     *
     * @param params Configuration for generating the DPoP proof
     * @param params.url The URL of the resource server endpoint
     * @param params.method The HTTP method (e.g., 'GET', 'POST')
     * @param params.nonce Optional DPoP nonce from the authorization server
     * @param params.accessToken The access token to bind to the proof
     * @returns An Observable that emits the generated DPoP proof as a JWT string.
     */
    generateDpopProof(params) {
        return from(this.auth0Client.generateDpopProof(params));
    }
    /**
     * ```js
     * const fetcher = createFetcher(config);
     * ```
     *
     * Creates a custom fetcher instance that can be used to make authenticated
     * HTTP requests. The fetcher automatically handles token refresh and can
     * be configured with custom request/response handling.
     *
     * @param config Optional configuration for the fetcher
     * @returns A Fetcher instance configured with the Auth0 client.
     */
    createFetcher(config) {
        return this.auth0Client.createFetcher(config);
    }
    shouldHandleCallback() {
        return of(location.search).pipe(map((search) => {
            const searchParams = new URLSearchParams(search);
            return ((searchParams.has('code') || searchParams.has('error')) &&
                searchParams.has('state') &&
                !this.configFactory.get().skipRedirectCallback);
        }));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: AuthService, deps: [{ token: Auth0ClientService }, { token: i1.AuthClientConfig }, { token: i2.AbstractNavigator }, { token: i3.AuthState }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: AuthService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: AuthService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: i4.Auth0Client, decorators: [{
                    type: Inject,
                    args: [Auth0ClientService]
                }] }, { type: i1.AuthClientConfig }, { type: i2.AbstractNavigator }, { type: i3.AuthState }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvYXV0aDAtYW5ndWxhci9zcmMvbGliL2F1dGguc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBYSxNQUFNLGVBQWUsQ0FBQztBQWdCOUQsT0FBTyxFQUNMLEVBQUUsRUFDRixJQUFJLEVBQ0osT0FBTyxFQUVQLEdBQUcsRUFDSCxLQUFLLEVBQ0wsYUFBYSxFQUNiLFVBQVUsR0FDWCxNQUFNLE1BQU0sQ0FBQztBQUVkLE9BQU8sRUFDTCxTQUFTLEVBQ1QsR0FBRyxFQUNILEdBQUcsRUFDSCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFNBQVMsRUFDVCxjQUFjLEdBQ2YsTUFBTSxnQkFBZ0IsQ0FBQztBQUV4QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxlQUFlLENBQUM7Ozs7OztBQVNuRCxNQUFNLE9BQU8sV0FBVztJQXVDdEIsWUFDc0MsV0FBd0IsRUFDcEQsYUFBK0IsRUFDL0IsU0FBNEIsRUFDNUIsU0FBb0I7UUFIUSxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUNwRCxrQkFBYSxHQUFiLGFBQWEsQ0FBa0I7UUFDL0IsY0FBUyxHQUFULFNBQVMsQ0FBbUI7UUFDNUIsY0FBUyxHQUFULFNBQVMsQ0FBVztRQXhDdEIscUJBQWdCLEdBQUcsSUFBSSxhQUFhLENBQVksQ0FBQyxDQUFDLENBQUM7UUFFM0QsdUNBQXVDO1FBQy9CLG1CQUFjLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztRQUM3Qzs7V0FFRztRQUNNLGVBQVUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQztRQUVoRDs7O1dBR0c7UUFDTSxxQkFBZ0IsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDO1FBRTVEOztXQUVHO1FBQ00sVUFBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMs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RlYsTUFBTTs7NEZBRVAsV0FBVztrQkFIdkIsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkI7OzBCQXlDSSxNQUFNOzJCQUFDLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7XG4gIEF1dGgwQ2xpZW50LFxuICBQb3B1cExvZ2luT3B0aW9ucyxcbiAgUG9wdXBDb25maWdPcHRpb25zLFxuICBHZXRUb2tlblNpbGVudGx5T3B0aW9ucyxcbiAgR2V0VG9rZW5XaXRoUG9wdXBPcHRpb25zLFxuICBSZWRpcmVjdExvZ2luUmVzdWx0LFxuICBHZXRUb2tlblNpbGVudGx5VmVyYm9zZVJlc3BvbnNlLFxuICBDb25uZWN0QWNjb3VudFJlZGlyZWN0UmVzdWx0LFxuICBDdXN0b21GZXRjaE1pbmltYWxPdXRwdXQsXG4gIEZldGNoZXIsXG4gIEZldGNoZXJDb25maWcsXG59IGZyb20gJ0BhdXRoMC9hdXRoMC1zcGEtanMnO1xuXG5pbXBvcnQge1xuICBvZixcbiAgZnJvbSxcbiAgU3ViamVjdCxcbiAgT2JzZXJ2YWJsZSxcbiAgaWlmLFxuICBkZWZlcixcbiAgUmVwbGF5U3ViamVjdCxcbiAgdGhyb3dFcnJvcixcbn0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7XG4gIGNvbmNhdE1hcCxcbiAgdGFwLFxuICBtYXAsXG4gIHRha2VVbnRpbCxcbiAgY2F0Y2hFcnJvcixcbiAgc3dpdGNoTWFwLFxuICB3aXRoTGF0ZXN0RnJvbSxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBBdXRoMENsaWVudFNlcnZpY2UgfSBmcm9tICcuL2F1dGguY2xpZW50JztcbmltcG9ydCB7IEFic3RyYWN0TmF2aWdhdG9yIH0gZnJvbSAnLi9hYnN0cmFjdC1uYXZpZ2F0b3InO1xuaW1wb3J0IHsgQXV0aENsaWVudENvbmZpZywgQXBwU3RhdGUgfSBmcm9tICcuL2F1dGguY29uZmlnJztcbmltcG9ydCB7IEF1dGhTdGF0ZSB9IGZyb20gJy4vYXV0aC5zdGF0ZSc7XG5pbXBvcnQgeyBMb2dvdXRPcHRpb25zLCBSZWRpcmVjdExvZ2luT3B0aW9ucyB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBBdXRoU2VydmljZTxUQXBwU3RhdGUgZXh0ZW5kcyBBcHBTdGF0ZSA9IEFwcFN0YXRlPlxuICBpbXBsZW1lbnRzIE9uRGVzdHJveVxue1xuICBwcml2YXRlIGFwcFN0YXRlU3ViamVjdCQgPSBuZXcgUmVwbGF5U3ViamVjdDxUQXBwU3RhdGU+KDEpO1xuXG4gIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MTE3NzE2M1xuICBwcml2YXRlIG5nVW5zdWJzY3JpYmUkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgLyoqXG4gICAqIEVtaXRzIGJvb2xlYW4gdmFsdWVzIGluZGljYXRpbmcgdGhlIGxvYWRpbmcgc3RhdGUgb2YgdGhlIFNESy5cbiAgICovXG4gIHJlYWRvbmx5IGlzTG9hZGluZyQgPSB0aGlzLmF1dGhTdGF0ZS5pc0xvYWRpbmckO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBib29sZWFuIHZhbHVlcyBpbmRpY2F0aW5nIHRoZSBhdXRoZW50aWNhdGlvbiBzdGF0ZSBvZiB0aGUgdXNlci4gSWYgYHRydWVgLCBpdCBtZWFucyBhIHVzZXIgaGFzIGF1dGhlbnRpY2F0ZWQuXG4gICAqIFRoaXMgZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgYGlzTG9hZGluZyRgLCBzbyB0aGVyZSBpcyBubyBuZWVkIHRvIG1hbnVhbGx5IGNoZWNrIHRoZSBsb2FkaW5nIHN0YXRlIG9mIHRoZSBTREsuXG4gICAqL1xuICByZWFkb25seSBpc0F1dGhlbnRpY2F0ZWQkID0gdGhpcy5hdXRoU3RhdGUuaXNBdXRoZW50aWNhdGVkJDtcblxuICAvKipcbiAgICogRW1pdHMgZGV0YWlscyBhYm91dCB0aGUgYXV0aGVudGljYXRlZCB1c2VyLCBvciBudWxsIGlmIG5vdCBhdXRoZW50aWNhdGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgdXNlciQgPSB0aGlzLmF1dGhTdGF0ZS51c2VyJDtcblxuICAvKipcbiAgICogRW1pdHMgSUQgdG9rZW4gY2xhaW1zIHdoZW4gYXV0aGVudGljYXRlZCwgb3IgbnVsbCBpZiBub3QgYXV0aGVudGljYXRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGlkVG9rZW5DbGFpbXMkID0gdGhpcy5hdXRoU3RhdGUuaWRUb2tlbkNsYWltcyQ7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGVycm9ycyB0aGF0IG9jY3VyIGR1cmluZyBsb2dpbiwgb3Igd2hlbiBjaGVja2luZyBmb3IgYW4gYWN0aXZlIHNlc3Npb24gb24gc3RhcnR1cC5cbiAgICovXG4gIHJlYWRvbmx5IGVycm9yJCA9IHRoaXMuYXV0aFN0YXRlLmVycm9yJDtcblxuICAvKipcbiAgICogRW1pdHMgdGhlIHZhbHVlIChpZiBhbnkpIHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgYGxvZ2luV2l0aFJlZGlyZWN0YCBtZXRob2QgY2FsbFxuICAgKiBidXQgb25seSAqKmFmdGVyKiogYGhhbmRsZVJlZGlyZWN0Q2FsbGJhY2tgIGlzIGZpcnN0IGNhbGxlZFxuICAgKi9cbiAgcmVhZG9ubHkgYXBwU3RhdGUkID0gdGhpcy5hcHBTdGF0ZVN1YmplY3QkLmFzT2JzZXJ2YWJsZSgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoQXV0aDBDbGllbnRTZXJ2aWNlKSBwcml2YXRlIGF1dGgwQ2xpZW50OiBBdXRoMENsaWVudCxcbiAgICBwcml2YXRlIGNvbmZpZ0ZhY3Rvcnk6IEF1dGhDbGllbnRDb25maWcsXG4gICAgcHJpdmF0ZSBuYXZpZ2F0b3I6IEFic3RyYWN0TmF2aWdhdG9yLFxuICAgIHByaXZhdGUgYXV0aFN0YXRlOiBBdXRoU3RhdGVcbiAgKSB7XG4gICAgY29uc3QgY2hlY2tTZXNzaW9uT3JDYWxsYmFjayQgPSAoaXNDYWxsYmFjazogYm9vbGVhbikgPT5cbiAgICAgIGlpZihcbiAgICAgICAgKCkgPT4gaXNDYWxsYmFjayxcbiAgICAgICAgdGhpcy5oYW5kbGVSZWRpcmVjdENhbGxiYWNrKCksXG4gICAgICAgIGRlZmVyKCgpID0+IHRoaXMuYXV0aDBDbGllbnQuY2hlY2tTZXNzaW9uKCkpXG4gICAgICApO1xuXG4gICAgdGhpcy5zaG91bGRIYW5kbGVDYWxsYmFjaygpXG4gICAgICAucGlwZShcbiAgICAgICAgc3dpdGNoTWFwKChpc0NhbGxiYWNrKSA9PlxuICAgICAgICAgIGNoZWNrU2Vzc2lvbk9yQ2FsbGJhY2skKGlzQ2FsbGJhY2spLnBpcGUoXG4gICAgICAgICAgICBjYXRjaEVycm9yKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZ0ZhY3RvcnkuZ2V0KCk7XG4gICAgICAgICAgICAgIHRoaXMubmF2aWdhdG9yLm5hdmlnYXRlQnlVcmwoY29uZmlnLmVycm9yUGF0aCB8fCAnLycpO1xuICAgICAgICAgICAgICB0aGlzLmF1dGhTdGF0ZS5zZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIHRhcCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hdXRoU3RhdGUuc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfSksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLm5nVW5zdWJzY3JpYmUkKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBzZXJ2aWNlIGlzIGRlc3Ryb3llZFxuICAgKi9cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQxMTc3MTYzXG4gICAgdGhpcy5uZ1Vuc3Vic2NyaWJlJC5uZXh0KCk7XG4gICAgdGhpcy5uZ1Vuc3Vic2NyaWJlJC5jb21wbGV0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIGBgYGpzXG4gICAqIGxvZ2luV2l0aFJlZGlyZWN0KG9wdGlvbnMpO1xuICAgKiBgYGBcbiAgICpcbiAgICogUGVyZm9ybXMgYSByZWRpcmVjdCB0byBgL2F1dGhvcml6ZWAgdXNpbmcgdGhlIHBhcmFtZXRlcnNcbiAgICogcHJvdmlkZWQgYXMgYXJndW1lbnRzLiBSYW5kb20gYW5kIHNlY3VyZSBgc3RhdGVgIGFuZCBgbm9uY2VgXG4gICAqIHBhcmFtZXRlcnMgd2lsbCBiZSBhdXRvLWdlbmVyYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGxvZ2luIG9wdGlvbnNcbiAgICovXG4gIGxvZ2luV2l0aFJlZGlyZWN0KFxuICAgIG9wdGlvbnM/OiBSZWRpcmVjdExvZ2luT3B0aW9uczxUQXBwU3RhdGU+XG4gICk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiBmcm9tKHRoaXMuYXV0aDBDbGllbnQubG9naW5XaXRoUmVkaXJlY3Qob3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIGBgYGpzXG4gICAqIGF3YWl0IGxvZ2luV2l0aFBvcHVwKG9wdGlvbnMpO1xuICAgKiBgYGBcbiAgICpcbiAgICogT3BlbnMgYSBwb3B1cCB3aXRoIHRoZSBgL2F1dGhvcml6ZWAgVVJMIHVzaW5nIHRoZSBwYXJhbWV0ZXJzXG4gICAqIHByb3ZpZGVkIGFzIGFyZ3VtZW50cy4gUmFuZG9tIGFuZCBzZWN1cmUgYHN0YXRlYCBhbmQgYG5vbmNlYFxuICAgKiBwYXJhbWV0ZXJzIHdpbGwgYmUgYXV0by1nZW5lcmF0ZWQuIElmIHRoZSByZXNwb25zZSBpcyBzdWNjZXNzZnVsLFxuICAgKiByZXN1bHRzIHdpbGwgYmUgdmFsaWQgYWNjb3JkaW5nIHRvIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG4gICAqXG4gICAqIElNUE9SVEFOVDogVGhpcyBtZXRob2QgaGFzIHRvIGJlIGNhbGxlZCBmcm9tIGFuIGV2ZW50IGhhbmRsZXJcbiAgICogdGhhdCB3YXMgc3RhcnRlZCBieSB0aGUgdXNlciBsaWtlIGEgYnV0dG9uIGNsaWNrLCBmb3IgZXhhbXBsZSxcbiAgICogb3RoZXJ3aXNlIHRoZSBwb3B1cCB3aWxsIGJlIGJsb2NrZWQgaW4gbW9zdCBicm93c2Vycy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGxvZ2luIG9wdGlvbnNcbiAgICogQHBhcmFtIGNvbmZpZyBDb25maWd1cmF0aW9uIGZvciB0aGUgcG9wdXAgd2luZG93XG4gICAqL1xuICBsb2dpbldpdGhQb3B1cChcbiAgICBvcHRpb25zPzogUG9wdXBMb2dpbk9wdGlvbnMsXG4gICAgY29uZmlnPzogUG9wdXBDb25maWdPcHRpb25zXG4gICk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiBmcm9tKFxuICAgICAgdGhpcy5hdXRoMENsaWVudC5sb2dpbldpdGhQb3B1cChvcHRpb25zLCBjb25maWcpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmF1dGhTdGF0ZS5yZWZyZXNoKCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogYGBganNcbiAgICogbG9nb3V0KCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBDbGVhcnMgdGhlIGFwcGxpY2F0aW9uIHNlc3Npb24gYW5kIHBlcmZvcm1zIGEgcmVkaXJlY3QgdG8gYC92Mi9sb2dvdXRgLCB1c2luZ1xuICAgKiB0aGUgcGFyYW1ldGVycyBwcm92aWRlZCBhcyBhcmd1bWVudHMsIHRvIGNsZWFyIHRoZSBBdXRoMCBzZXNzaW9uLlxuICAgKiBJZiB0aGUgYGZlZGVyYXRlZGAgb3B0aW9uIGlzIHNwZWNpZmllZCBpdCBhbHNvIGNsZWFycyB0aGUgSWRlbnRpdHkgUHJvdmlkZXIgc2Vzc2lvbi5cbiAgICogSWYgdGhlIGBvcGVuVXJsYCBvcHRpb24gaXMgc2V0IHRvIGZhbHNlLCBpdCBvbmx5IGNsZWFycyB0aGUgYXBwbGljYXRpb24gc2Vzc2lvbi5cbiAgICogSXQgaXMgaW52YWxpZCB0byBzZXQgYm90aCB0aGUgYGZlZGVyYXRlZGAgdG8gdHJ1ZSBhbmQgYG9wZW5VcmxgIHRvIGBmYWxzZWAsXG4gICAqIGFuZCBhbiBlcnJvciB3aWxsIGJlIHRocm93biBpZiB5b3UgZG8uXG4gICAqIFtSZWFkIG1vcmUgYWJvdXQgaG93IExvZ291dCB3b3JrcyBhdCBBdXRoMF0oaHR0cHM6Ly9hdXRoMC5jb20vZG9jcy9sb2dvdXQpLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgbG9nb3V0IG9wdGlvbnNcbiAgICovXG4gIGxvZ291dChvcHRpb25zPzogTG9nb3V0T3B0aW9ucyk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiBmcm9tKFxuICAgICAgdGhpcy5hdXRoMENsaWVudC5sb2dvdXQob3B0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zPy5vcGVuVXJsID09PSBmYWxzZSB8fCBvcHRpb25zPy5vcGVuVXJsKSB7XG4gICAgICAgICAgdGhpcy5hdXRoU3RhdGUucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhIG5ldyBhY2Nlc3MgdG9rZW4gYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlIGZyb20gdGhlIC9vYXV0aC90b2tlbiBlbmRwb2ludCwgb21pdHRpbmcgdGhlIHJlZnJlc2ggdG9rZW4uXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBjb25maWd1cmluZyB0aGUgdG9rZW4gZmV0Y2guXG4gICAqL1xuICBnZXRBY2Nlc3NUb2tlblNpbGVudGx5KFxuICAgIG9wdGlvbnM6IEdldFRva2VuU2lsZW50bHlPcHRpb25zICYgeyBkZXRhaWxlZFJlc3BvbnNlOiB0cnVlIH1cbiAgKTogT2JzZXJ2YWJsZTxHZXRUb2tlblNpbGVudGx5VmVyYm9zZVJlc3BvbnNlPjtcblxuICAvKipcbiAgICogRmV0Y2hlcyBhIG5ldyBhY2Nlc3MgdG9rZW4gYW5kIHJldHVybnMgaXQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBjb25maWd1cmluZyB0aGUgdG9rZW4gZmV0Y2guXG4gICAqL1xuICBnZXRBY2Nlc3NUb2tlblNpbGVudGx5KG9wdGlvbnM/OiBHZXRUb2tlblNpbGVudGx5T3B0aW9ucyk6IE9ic2VydmFibGU8c3RyaW5nPjtcblxuICAvKipcbiAgICogYGBganNcbiAgICogZ2V0QWNjZXNzVG9rZW5TaWxlbnRseShvcHRpb25zKS5zdWJzY3JpYmUodG9rZW4gPT4gLi4uKVxuICAgKiBgYGBcbiAgICpcbiAgICogSWYgdGhlcmUncyBhIHZhbGlkIHRva2VuIHN0b3JlZCwgcmV0dXJuIGl0LiBPdGhlcndpc2UsIG9wZW5zIGFuXG4gICAqIGlmcmFtZSB3aXRoIHRoZSBgL2F1dGhvcml6ZWAgVVJMIHVzaW5nIHRoZSBwYXJhbWV0ZXJzIHByb3ZpZGVkXG4gICAqIGFzIGFyZ3VtZW50cy4gUmFuZG9tIGFuZCBzZWN1cmUgYHN0YXRlYCBhbmQgYG5vbmNlYCBwYXJhbWV0ZXJzXG4gICAqIHdpbGwgYmUgYXV0by1nZW5lcmF0ZWQuIElmIHRoZSByZXNwb25zZSBpcyBzdWNjZXNzZnVsLCByZXN1bHRzXG4gICAqIHdpbGwgYmUgdmFsaWQgYWNjb3JkaW5nIHRvIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG4gICAqXG4gICAqIElmIHJlZnJlc2ggdG9rZW5zIGFyZSB1c2VkLCB0aGUgdG9rZW4gZW5kcG9pbnQgaXMgY2FsbGVkIGRpcmVjdGx5IHdpdGggdGhlXG4gICAqICdyZWZyZXNoX3Rva2VuJyBncmFudC4gSWYgbm8gcmVmcmVzaCB0b2tlbiBpcyBhdmFpbGFibGUgdG8gbWFrZSB0aGlzIGNhbGwsXG4gICAqIHRoZSBTREsgZmFsbHMgYmFjayB0byB1c2luZyBhbiBpZnJhbWUgdG8gdGhlICcvYXV0aG9yaXplJyBVUkwuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIG1heSB1c2UgYSB3ZWIgd29ya2VyIHRvIHBlcmZvcm0gdGhlIHRva2VuIGNhbGwgaWYgdGhlIGluLW1lbW9yeVxuICAgKiBjYWNoZSBpcyB1c2VkLlxuICAgKlxuICAgKiBJZiBhbiBgYXVkaWVuY2VgIHZhbHVlIGlzIGdpdmVuIHRvIHRoaXMgZnVuY3Rpb24sIHRoZSBTREsgYWx3YXlzIGZhbGxzXG4gICAqIGJhY2sgdG8gdXNpbmcgYW4gaWZyYW1lIHRvIG1ha2UgdGhlIHRva2VuIGV4Y2hhbmdlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaW4gYWxsIGNhc2VzLCBmYWxsaW5nIGJhY2sgdG8gYW4gaWZyYW1lIHJlcXVpcmVzIGFjY2VzcyB0b1xuICAgKiB0aGUgYGF1dGgwYCBjb29raWUsIGFuZCB0aHVzIHdpbGwgbm90IHdvcmsgaW4gYnJvd3NlcnMgdGhhdCBibG9jayB0aGlyZC1wYXJ0eVxuICAgKiBjb29raWVzIGJ5IGRlZmF1bHQgKFNhZmFyaSwgQnJhdmUsIGV0YykuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBjb25maWd1cmluZyB0aGUgdG9rZW4gZmV0Y2guXG4gICAqL1xuICBnZXRBY2Nlc3NUb2tlblNpbGVudGx5KFxuICAgIG9wdGlvbnM6IEdldFRva2VuU2lsZW50bHlPcHRpb25zID0ge31cbiAgKTogT2JzZXJ2YWJsZTxzdHJpbmcgfCBHZXRUb2tlblNpbGVudGx5VmVyYm9zZVJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIG9mKHRoaXMuYXV0aDBDbGllbnQpLnBpcGUoXG4gICAgICBjb25jYXRNYXAoKGNsaWVudCkgPT5cbiAgICAgICAgb3B0aW9ucy5kZXRhaWxlZFJlc3BvbnNlID09PSB0cnVlXG4gICAgICAgICAgPyBjbGllbnQuZ2V0VG9rZW5TaWxlbnRseSh7IC4uLm9wdGlvbnMsIGRldGFpbGVkUmVzcG9uc2U6IHRydWUgfSlcbiAgICAgICAgICA6IGNsaWVudC5nZXRUb2tlblNpbGVudGx5KG9wdGlvbnMpXG4gICAgICApLFxuICAgICAgdGFwKCh0b2tlbikgPT4ge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICB0aGlzLmF1dGhTdGF0ZS5zZXRBY2Nlc3NUb2tlbihcbiAgICAgICAgICAgIHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgPyB0b2tlbiA6IHRva2VuLmFjY2Vzc190b2tlblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgY2F0Y2hFcnJvcigoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5hdXRoU3RhdGUuc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICB0aGlzLmF1dGhTdGF0ZS5yZWZyZXNoKCk7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBgYGBqc1xuICAgKiBnZXRUb2tlbldpdGhQb3B1cChvcHRpb25zKS5zdWJzY3JpYmUodG9rZW4gPT4gLi4uKVxuICAgKiBgYGBcbiAgICpcbiAgICogR2V0IGFuIGFjY2VzcyB0b2tlbiBpbnRlcmFjdGl2ZWx5LlxuICAgKlxuICAgKiBPcGVucyBhIHBvcHVwIHdpdGggdGhlIGAvYXV0aG9yaXplYCBVUkwgdXNpbmcgdGhlIHBhcmFtZXRlcnNcbiAgICogcHJvdmlkZWQgYXMgYXJndW1lbnRzLiBSYW5kb20gYW5kIHNlY3VyZSBgc3RhdGVgIGFuZCBgbm9uY2VgXG4gICAqIHBhcmFtZXRlcnMgd2lsbCBiZSBhdXRvLWdlbmVyYXRlZC4gSWYgdGhlIHJlc3BvbnNlIGlzIHN1Y2Nlc3NmdWwsXG4gICAqIHJlc3VsdHMgd2lsbCBiZSB2YWxpZCBhY2NvcmRpbmcgdG8gdGhlaXIgZXhwaXJhdGlvbiB0aW1lcy5cbiAgICovXG4gIGdldEFjY2Vzc1Rva2VuV2l0aFBvcHVwKFxuICAgIG9wdGlvbnM/OiBHZXRUb2tlbldpdGhQb3B1cE9wdGlvbnNcbiAgKTogT2JzZXJ2YWJsZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gb2YodGhpcy5hdXRoMENsaWVudCkucGlwZShcbiAgICAgIGNvbmNhdE1hcCgoY2xpZW50KSA9PiBjbGllbnQuZ2V0VG9rZW5XaXRoUG9wdXAob3B0aW9ucykpLFxuICAgICAgdGFwKCh0b2tlbikgPT4ge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICB0aGlzLmF1dGhTdGF0ZS5zZXRBY2Nlc3NUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgY2F0Y2hFcnJvcigoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5hdXRoU3RhdGUuc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICB0aGlzLmF1dGhTdGF0ZS5yZWZyZXNoKCk7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBgYGBqc1xuICAgKiBoYW5kbGVSZWRpcmVjdENhbGxiYWNrKHVybCkuc3Vic2NyaWJlKHJlc3VsdCA9PiAuLi4pXG4gICAqIGBgYFxuICAgKlxuICAgKiBBZnRlciB0aGUgYnJvd3NlciByZWRpcmVjdHMgYmFjayB0byB0aGUgY2FsbGJhY2sgcGFnZSxcbiAgICogY2FsbCBgaGFuZGxlUmVkaXJlY3RDYWxsYmFja2AgdG8gaGFuZGxlIHN1Y2Nlc3MgYW5kIGVycm9yXG4gICAqIHJlc3BvbnNlcyBmcm9tIEF1dGgwLiBJZiB0aGUgcmVzcG9uc2UgaXMgc3VjY2Vzc2Z1bCwgcmVzdWx0c1xuICAgKiB3aWxsIGJlIHZhbGlkIGFjY29yZGluZyB0byB0aGVpciBleHBpcmF0aW9uIHRpbWVzLlxuICAgKlxuICAgKiBDYWxsaW5nIHRoaXMgbWV0aG9kIGFsc28gcmVmcmVzaGVzIHRoZSBhdXRoZW50aWNhdGlvbiBhbmQgdXNlciBzdGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB1cmwgVGhlIFVSTCB0byB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJldHJpZXZlIHRoZSBgc3RhdGVgIGFuZCBgY29kZWAgdmFsdWVzLiBEZWZhdWx0cyB0byBgd2luZG93LmxvY2F0aW9uLmhyZWZgIGlmIG5vdCBnaXZlbi5cbiAgICovXG4gIGhhbmRsZVJlZGlyZWN0Q2FsbGJhY2soXG4gICAgdXJsPzogc3RyaW5nXG4gICk6IE9ic2VydmFibGU8XG4gICAgUmVkaXJlY3RMb2dpblJlc3VsdDxUQXBwU3RhdGU+IHwgQ29ubmVjdEFjY291bnRSZWRpcmVjdFJlc3VsdDxUQXBwU3RhdGU+XG4gID4ge1xuICAgIHJldHVybiBkZWZlcigoKSA9PlxuICAgICAgdGhpcy5hdXRoMENsaWVudC5oYW5kbGVSZWRpcmVjdENhbGxiYWNrPFRBcHBTdGF0ZT4odXJsKVxuICAgICkucGlwZShcbiAgICAgIHdpdGhMYXRlc3RGcm9tKHRoaXMuYXV0aFN0YXRlLmlzTG9hZGluZyQpLFxuICAgICAgdGFwKChbcmVzdWx0LCBpc0xvYWRpbmddKSA9PiB7XG4gICAgICAgIGlmICghaXNMb2FkaW5nKSB7XG4gICAgICAgICAgdGhpcy5hdXRoU3RhdGUucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcFN0YXRlID0gcmVzdWx0Py5hcHBTdGF0ZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXBwU3RhdGU/LnRhcmdldCA/PyAnLyc7XG5cbiAgICAgICAgaWYgKGFwcFN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5hcHBTdGF0ZVN1YmplY3QkLm5leHQoYXBwU3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uYXZpZ2F0b3IubmF2aWdhdGVCeVVybCh0YXJnZXQpO1xuICAgICAgfSksXG4gICAgICBtYXAoKFtyZXN1bHRdKSA9PiByZXN1bHQpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBgYGBqc1xuICAgKiBnZXREcG9wTm9uY2UoaWQpLnN1YnNjcmliZShub25jZSA9PiAuLi4pXG4gICAqIGBgYFxuICAgKlxuICAgKiBHZXRzIHRoZSBEUG9QIG5vbmNlIGZvciB0aGUgc3BlY2lmaWVkIGRvbWFpbiBvciB0aGUgZGVmYXVsdCBkb21haW4uXG4gICAqIFRoZSBub25jZSBpcyB1c2VkIGluIERQb1AgcHJvb2YgZ2VuZXJhdGlvbiBmb3IgdG9rZW4gYmluZGluZy5cbiAgICpcbiAgICogQHBhcmFtIGlkIE9wdGlvbmFsIGlkZW50aWZpZXIgZm9yIHRoZSBkb21haW4uIElmIG5vdCBwcm92aWRlZCwgdXNlcyB0aGUgZGVmYXVsdCBkb21haW4uXG4gICAqIEByZXR1cm5zIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgRFBvUCBub25jZSBzdHJpbmcgb3IgdW5kZWZpbmVkIGlmIG5vdCBhdmFpbGFibGUuXG4gICAqL1xuICBnZXREcG9wTm9uY2UoaWQ/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiBmcm9tKHRoaXMuYXV0aDBDbGllbnQuZ2V0RHBvcE5vbmNlKGlkKSk7XG4gIH1cblxuICAvKipcbiAgICogYGBganNcbiAgICogc2V0RHBvcE5vbmNlKG5vbmNlLCBpZCkuc3Vic2NyaWJlKCgpID0+IC4uLilcbiAgICogYGBgXG4gICAqXG4gICAqIFNldHMgdGhlIERQb1Agbm9uY2UgZm9yIHRoZSBzcGVjaWZpZWQgZG9tYWluIG9yIHRoZSBkZWZhdWx0IGRvbWFpbi5cbiAgICogVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCBhZnRlciByZWNlaXZpbmcgYSBuZXcgbm9uY2UgZnJvbSB0aGUgYXV0aG9yaXphdGlvbiBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBub25jZSBUaGUgRFBvUCBub25jZSB2YWx1ZSB0byBzZXQuXG4gICAqIEBwYXJhbSBpZCBPcHRpb25hbCBpZGVudGlmaWVyIGZvciB0aGUgZG9tYWluLiBJZiBub3QgcHJvdmlkZWQsIHVzZXMgdGhlIGRlZmF1bHQgZG9tYWluLlxuICAgKiBAcmV0dXJucyBBbiBPYnNlcnZhYmxlIHRoYXQgY29tcGxldGVzIHdoZW4gdGhlIG5vbmNlIGlzIHNldC5cbiAgICovXG4gIHNldERwb3BOb25jZShub25jZTogc3RyaW5nLCBpZD86IHN0cmluZyk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiBmcm9tKHRoaXMuYXV0aDBDbGllbnQuc2V0RHBvcE5vbmNlKG5vbmNlLCBpZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIGBgYGpzXG4gICAqIGdlbmVyYXRlRHBvcFByb29mKHBhcmFtcykuc3Vic2NyaWJlKHByb29mID0+IC4uLilcbiAgICogYGBgXG4gICAqXG4gICAqIEdlbmVyYXRlcyBhIERQb1AgKERlbW9uc3RyYXRpbmcgUHJvb2Ytb2YtUG9zc2Vzc2lvbikgcHJvb2YgSldULlxuICAgKiBUaGlzIHByb29mIGlzIHVzZWQgdG8gYmluZCBhY2Nlc3MgdG9rZW5zIHRvIGEgc3BlY2lmaWMgY2xpZW50LCBwcm92aWRpbmdcbiAgICogYW4gYWRkaXRpb25hbCBsYXllciBvZiBzZWN1cml0eSBmb3IgdG9rZW4gdXNhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgQ29uZmlndXJhdGlvbiBmb3IgZ2VuZXJhdGluZyB0aGUgRFBvUCBwcm9vZlxuICAgKiBAcGFyYW0gcGFyYW1zLnVybCBUaGUgVVJMIG9mIHRoZSByZXNvdXJjZSBzZXJ2ZXIgZW5kcG9pbnRcbiAgICogQHBhcmFtIHBhcmFtcy5tZXRob2QgVGhlIEhUVFAgbWV0aG9kIChlLmcuLCAnR0VUJywgJ1BPU1QnKVxuICAgKiBAcGFyYW0gcGFyYW1zLm5vbmNlIE9wdGlvbmFsIERQb1Agbm9uY2UgZnJvbSB0aGUgYXV0aG9yaXphdGlvbiBzZXJ2ZXJcbiAgICogQHBhcmFtIHBhcmFtcy5hY2Nlc3NUb2tlbiBUaGUgYWNjZXNzIHRva2VuIHRvIGJpbmQgdG8gdGhlIHByb29mXG4gICAqIEByZXR1cm5zIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgZ2VuZXJhdGVkIERQb1AgcHJvb2YgYXMgYSBKV1Qgc3RyaW5nLlxuICAgKi9cbiAgZ2VuZXJhdGVEcG9wUHJvb2YocGFyYW1zOiB7XG4gICAgdXJsOiBzdHJpbmc7XG4gICAgbWV0aG9kOiBzdHJpbmc7XG4gICAgbm9uY2U/OiBzdHJpbmc7XG4gICAgYWNjZXNzVG9rZW46IHN0cmluZztcbiAgfSk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG4gICAgcmV0dXJuIGZyb20odGhpcy5hdXRoMENsaWVudC5nZW5lcmF0ZURwb3BQcm9vZihwYXJhbXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBmZXRjaGVyID0gY3JlYXRlRmV0Y2hlcihjb25maWcpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQ3JlYXRlcyBhIGN1c3RvbSBmZXRjaGVyIGluc3RhbmNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFrZSBhdXRoZW50aWNhdGVkXG4gICAqIEhUVFAgcmVxdWVzdHMuIFRoZSBmZXRjaGVyIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyB0b2tlbiByZWZyZXNoIGFuZCBjYW5cbiAgICogYmUgY29uZmlndXJlZCB3aXRoIGN1c3RvbSByZXF1ZXN0L3Jlc3BvbnNlIGhhbmRsaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gY29uZmlnIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBmZXRjaGVyXG4gICAqIEByZXR1cm5zIEEgRmV0Y2hlciBpbnN0YW5jZSBjb25maWd1cmVkIHdpdGggdGhlIEF1dGgwIGNsaWVudC5cbiAgICovXG4gIGNyZWF0ZUZldGNoZXI8VE91dHB1dCBleHRlbmRzIEN1c3RvbUZldGNoTWluaW1hbE91dHB1dCA9IFJlc3BvbnNlPihcbiAgICBjb25maWc/OiBGZXRjaGVyQ29uZmlnPFRPdXRwdXQ+XG4gICk6IEZldGNoZXI8VE91dHB1dD4ge1xuICAgIHJldHVybiB0aGlzLmF1dGgwQ2xpZW50LmNyZWF0ZUZldGNoZXIoY29uZmlnKTtcbiAgfVxuXG4gIHByaXZhdGUgc2hvdWxkSGFuZGxlQ2FsbGJhY2soKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIG9mKGxvY2F0aW9uLnNlYXJjaCkucGlwZShcbiAgICAgIG1hcCgoc2VhcmNoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoc2VhcmNoUGFyYW1zLmhhcygnY29kZScpIHx8IHNlYXJjaFBhcmFtcy5oYXMoJ2Vycm9yJykpICYmXG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmhhcygnc3RhdGUnKSAmJlxuICAgICAgICAgICF0aGlzLmNvbmZpZ0ZhY3RvcnkuZ2V0KCkuc2tpcFJlZGlyZWN0Q2FsbGJhY2tcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIl19